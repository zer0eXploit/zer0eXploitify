import {
  Box,
  Text,
  Flex,
  Input,
  Image,
  Heading,
  Container,
  CloseButton,
} from "@chakra-ui/react";
import { HashLoader } from "react-spinners";
import { FC, useCallback, useReducer } from "react";

import { MediaCard } from "../media-card";
import { useAuth } from "../../context/auth-context";

import { createDebouncedFunc, spotifyAPI } from "../../utils";

import classes from "./index.module.css";

enum ActionTypes {
  DATA_FETCH = "DATA_FETCH",
  SEARCH_FOCUS = "SEARCH_FOCUS",
}

enum STATUS {
  IDLE = "IDLE",
  ERROR = "ERROR",
  PENDING = "PENDING",
  RESOLVED = "RESOLVED",
}

type Album = {
  name: string;
  images: string[];
  uri: string;
};

type Playlist = {
  name: string;
  images: string[];
  uri: string;
};

type Artist = {
  name: string;
  images: string[];
  popularity?: number;
  uri: string;
};

type Track = {
  name: string;
  uri: string;
  images: string[];
  popularity?: number;
};

type StateData = {
  albums: Album[];
  tracks: Track[];
  artists: Artist[];
  playlists: Playlist[];
};

interface State {
  q?: string;
  data?: StateData | null;
  status?: STATUS;
  searchFocus?: boolean;
}

interface Action {
  type: ActionTypes;
  payload?: State;
}

let controller: any;

const initialState: State = {
  q: "",
  data: null,
  status: STATUS.IDLE,
  searchFocus: false,
};

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case ActionTypes.SEARCH_FOCUS:
      return { ...state, ...action.payload };

    case ActionTypes.DATA_FETCH:
      return { ...state, ...action.payload };

    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
};

export const Search: FC = () => {
  const { accessToken } = useAuth();
  const [state, dispatch] = useReducer(reducer, initialState);

  const { searchFocus, data, status, q } = state;

  const totalResult =
    data &&
    Object.keys(data).reduce((acc, cur) => {
      if (data[cur as keyof StateData]?.length) {
        return acc + data[cur as keyof StateData]?.length;
      }
      return acc;
    }, 0);

  const handleKeyDown = useCallback((e: any) => {
    switch (e.keyCode) {
      // ESC
      case 27: {
        // to make subsequent key presses work
        e.target.blur();

        if (controller) controller.abort();

        return dispatch({
          type: ActionTypes.SEARCH_FOCUS,
          payload: { searchFocus: false, q: "" },
        });
      }

      default:
        break;
    }
  }, []);

  // eslint-disable-next-line
  const stableSearch = useCallback(
    createDebouncedFunc({
      fn: async (term: string) => {
        // cancel the previous request
        if (controller) controller.abort();

        controller = new AbortController();

        if (term.length === 0) {
          return dispatch({
            type: ActionTypes.DATA_FETCH,
            payload: { status: STATUS.RESOLVED },
          });
        }

        spotifyAPI
          .get("/search", {
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${accessToken}`,
            },
            params: {
              q: term,
              type: "album,artist,playlist,track",
            },
            signal: controller.signal,
          })
          .then(({ data }) => {
            if (data) {
              const transformedData = {
                albums: data?.albums?.items?.map(
                  ({ name, images, uri }: any): Album => {
                    return {
                      uri,
                      name,
                      images: images.map(({ url }: { url: string }) => url),
                    };
                  }
                ),
                artists: data?.artists?.items?.map(
                  ({ name, images, popularity, uri }: any) => {
                    return {
                      uri,
                      name,
                      popularity,
                      images: images.map(({ url }: { url: string }) => url),
                    };
                  }
                ),
                playlists: data?.playlists?.items?.map(
                  ({ name, images, uri }: any): Album => {
                    return {
                      uri,
                      name,
                      images: images.map(({ url }: { url: string }) => url),
                    };
                  }
                ),
                tracks: data?.tracks?.items?.map(
                  ({ name, album, uri }: any): Album => {
                    return {
                      uri,
                      name,
                      images: album?.images?.map(
                        ({ url }: { url: string }) => url
                      ),
                    };
                  }
                ),
              };
              dispatch({
                type: ActionTypes.DATA_FETCH,
                payload: {
                  data: transformedData,
                  status: STATUS.RESOLVED,
                },
              });
            }
          })
          .catch((e) => {
            dispatch({
              type: ActionTypes.DATA_FETCH,
              payload: {
                status: STATUS.ERROR,
              },
            });
            console.error(e.message);
          });
      },
      ms: 500,
    }),
    [accessToken]
  );

  return (
    <div
      className={
        searchFocus
          ? `${classes["search-container"]} ${classes["search-container--active"]}`
          : classes["search-container"]
      }
    >
      <Input
        type="text"
        focusBorderColor="transparent"
        onKeyDown={handleKeyDown}
        onFocus={() => {
          if (!searchFocus) {
            dispatch({
              type: ActionTypes.SEARCH_FOCUS,
              payload: { searchFocus: true },
            });
          }
        }}
        value={q}
        className={classes["search-container__search-bar"]}
        placeholder="Search tracks, artists, albums, playlists..."
        _placeholder={{ opacity: 1, color: "gray.900" }}
        onChange={(e) => {
          dispatch({
            type: ActionTypes.DATA_FETCH,
            payload: { status: STATUS.PENDING, q: e.target.value },
          });
          stableSearch(e.target.value);
        }}
      />
      <div
        className={
          searchFocus
            ? `${classes["search-result-container"]} ${classes["search-result-container--active"]}`
            : classes["search-result-container"]
        }
      >
        <Container maxWidth="1920px" height="100%">
          {searchFocus && (
            <Box
              position="fixed"
              top="45px"
              right="10px"
              backgroundColor="whiteAlpha.700"
              borderRadius="lg"
              overflow="hidden"
            >
              <CloseButton
                size="lg"
                onClick={() =>
                  dispatch({
                    type: ActionTypes.SEARCH_FOCUS,
                    payload: { searchFocus: false, q: "" },
                  })
                }
              />
            </Box>
          )}
          {status === STATUS.PENDING ? (
            <Flex
              direction="column"
              justify="center"
              align="center"
              height="100%"
            >
              <HashLoader size={40} />
              <Text fontSize="md" mt="3">
                Loading...
              </Text>
            </Flex>
          ) : (
            <>
              {!Boolean(totalResult) && (
                <Flex
                  direction="column"
                  justify="center"
                  align="center"
                  height="100%"
                >
                  <Image src="/ghost.svg" alt="Empty Ghost" htmlWidth="120" />
                  <Text fontSize="md" mt="5">
                    There is nothing here...
                  </Text>
                </Flex>
              )}
              {data?.tracks?.length && data.tracks.length > 0 && (
                <>
                  <Heading fontSize="3xl" marginY="1.5rem">
                    Tracks
                  </Heading>
                  <Flex direction="row" wrap="wrap" gap="1.5rem">
                    {data.tracks.map(({ name, images, uri }) => {
                      return (
                        <MediaCard
                          key={uri}
                          title={name}
                          spotifyUri={uri}
                          imageUrl={images[0]}
                        />
                      );
                    })}
                  </Flex>
                </>
              )}
              {data?.albums?.length && data.albums.length > 0 && (
                <>
                  <Heading fontSize="3xl" marginY="1.5rem">
                    Albums
                  </Heading>
                  <Flex direction="row" wrap="wrap" gap="1.5rem">
                    {data.albums.map(({ name, images, uri }) => {
                      return (
                        <MediaCard
                          key={uri}
                          title={name}
                          spotifyUri={uri}
                          imageUrl={images[0]}
                        />
                      );
                    })}
                  </Flex>
                </>
              )}
              {data?.artists?.length && data.artists.length > 0 && (
                <>
                  <Heading fontSize="3xl" marginY="1.5rem">
                    Artists
                  </Heading>
                  <Flex direction="row" wrap="wrap" gap="1.5rem">
                    {data.artists.map(({ name, images, uri }) => {
                      return (
                        <MediaCard
                          key={uri}
                          title={name}
                          spotifyUri={uri}
                          imageUrl={images[0]}
                        />
                      );
                    })}
                  </Flex>
                </>
              )}
              {data?.playlists?.length && data.playlists.length > 0 && (
                <>
                  <Heading fontSize="3xl" marginY="1.5rem">
                    Playlists
                  </Heading>
                  <Flex direction="row" wrap="wrap" gap="1.5rem">
                    {data.playlists.map(({ name, images, uri }) => {
                      return (
                        <MediaCard
                          key={uri}
                          title={name}
                          spotifyUri={uri}
                          imageUrl={images[0]}
                        />
                      );
                    })}
                  </Flex>
                </>
              )}
            </>
          )}
        </Container>
      </div>
    </div>
  );
};
