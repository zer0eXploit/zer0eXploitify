import {
  Text,
  Flex,
  Image,
  Stack,
  Button,
  Spinner,
  useToast,
  Container,
  AlertDialog,
  AlertDialogBody,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogContent,
  AlertDialogOverlay,
} from "@chakra-ui/react";
import axios from "axios";
import Head from "next/head";
import { BeatLoader } from "react-spinners";
import { useEffect, useReducer, useRef } from "react";

import { useAuth } from "../../context/auth-context";

import { Search } from "../../components";

import { spotifyAPI } from "../../utils";

declare global {
  interface Window {
    Spotify: any;
    Vibrant: any;
    onSpotifyWebPlaybackSDKReady: any;
  }
}

enum ActionTypes {
  TOGGLE = "TOGGLE",
  TRACK_UPDATE = "TRACK_UPDATE",
  UPDATE_DEVICE = "UPDATE_DEVICE",
}

enum STATUS {
  IDLE = "IDLE",
  ERROR = "ERROR",
  PENDING = "PENDING",
  RESOLVED = "RESOLVED",
}

enum OP {
  PREV = "PREV",
  NEXT = "NEXT",
  NONE = "NONE",
  PLAYPAUSE = "PLAYPAUSE",
}

type CurrentTrack = {
  uri: string | null;
  name: string | null;
  imageUrl: string | null;
};

interface State {
  op?: OP; // operation
  st?: STATUS;
  deviceId?: string | null;
  playing?: boolean;
  currentTrack?: CurrentTrack;
}

interface Action {
  type: ActionTypes;
  payload: State;
}

const initialState: State = {
  playing: false,
  deviceId: null,
  st: STATUS.IDLE,
  currentTrack: { uri: null, name: null, imageUrl: null },
};

const reducer = (state: State, action: Action) => {
  switch (action.type) {
    case ActionTypes.TOGGLE:
      return { ...state, ...action.payload };
    case ActionTypes.TRACK_UPDATE:
      return { ...state, ...action.payload };
    case ActionTypes.UPDATE_DEVICE:
      return { ...state, ...action.payload };

    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
};

export default function Player() {
  const toast = useToast();
  const [state, dispatch] = useReducer(reducer, initialState);
  const { accessToken, refreshToken, setAuthData } = useAuth();
  const cancelRef = useRef() as React.MutableRefObject<HTMLElement>;

  const { playing, currentTrack, st, op, deviceId } = state;

  useEffect(() => {
    if (!accessToken) window.location.href = "/";
  });

  useEffect(() => {
    // transfer playback to this device
    deviceId &&
      spotifyAPI({
        url: "/me/player",
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`,
        },
        data: {
          play: playing ? true : false,
          device_ids: [deviceId],
        },
      });
    // if access token is changed,
    // it is not necessary to transfer again
    // eslint-disable-next-line
  }, [accessToken, deviceId]);

  useEffect(() => {
    if (typeof window !== "undefined" && accessToken?.length > 0) {
      let done = false;

      window.onSpotifyWebPlaybackSDKReady = async () => {
        const player = new window.Spotify.Player({
          name: "zer0eXploitify",
          getOAuthToken: async (cb: (token: string) => void) => {
            if (!done) {
              cb(accessToken);
              done = true;
            } else {
              // try to get a new access token with the refresh token
              console.log("[Auth]: Refreshing access token...");
              if (refreshToken) {
                try {
                  const resp = await axios.post("/api/v1/auth/spotify", {
                    refreshToken,
                  });
                  setAuthData({
                    refreshToken,
                    accessToken: resp?.data?.accessToken,
                  });
                  cb(resp?.data?.accessToken);
                } catch (error) {
                  // will force user to login again
                  setAuthData({});
                }
              }
            }
          },
          volume: 0.5,
        });

        if (player) {
          player.addListener("ready", ({ device_id }: any) => {
            dispatch({
              type: ActionTypes.UPDATE_DEVICE,
              payload: { deviceId: device_id },
            });
            console.log("Ready with Device ID", device_id);
          });

          player.addListener("not_ready", ({ device_id }: any) => {
            console.log("Device ID has gone offline", device_id);
          });

          player.addListener("initialization_error", ({ message }: any) => {
            console.error(message);
            dispatch({
              type: ActionTypes.TOGGLE,
              payload: { playing: false, st: STATUS.ERROR },
            });
          });

          player.addListener("authentication_error", ({ message }: any) => {
            // accessToken expired or there is none
            console.error(message);
            dispatch({
              type: ActionTypes.TOGGLE,
              payload: { playing: false, st: STATUS.ERROR },
            });
          });

          player.addListener("account_error", ({ message }: any) => {
            console.error(message);
            dispatch({
              type: ActionTypes.TOGGLE,
              payload: { playing: false, st: STATUS.ERROR },
            });
          });

          player.addListener("player_state_changed", (payload: any) => {
            if (!payload) return;

            if (
              payload?.context?.uri === null ||
              payload?.context?.uri === undefined
            ) {
              return toast({
                status: "info",
                position: "top",
                isClosable: true,
                title: "Device Switched",
                description:
                  "Playback is currently being played on another device.",
              });
            }

            const { track_window, paused } = payload;
            const { current_track } = track_window;
            const images = track_window?.current_track?.album.images ?? [];
            const imageUrl = images[images.length - 1]?.url ?? "";

            if (currentTrack?.uri === current_track.uri) return;

            if (paused) {
              dispatch({
                type: ActionTypes.TOGGLE,
                payload: { playing: false },
              });
            } else {
              dispatch({
                type: ActionTypes.TOGGLE,
                payload: { playing: true },
              });
            }

            window.Vibrant.from(imageUrl).getPalette(
              (_err: any, palette: any) => {
                const { DarkVibrant, Vibrant } = palette;

                const from = Vibrant.rgb.reduce(
                  (color: string, cur: number) => color + cur.toFixed(2) + ", ",
                  ""
                );
                const to = DarkVibrant.rgb.reduce(
                  (color: string, cur: number) => color + cur.toFixed(2) + ", ",
                  ""
                );

                document.body.style.backgroundSize = "cover";
                document.body.style.backdropFilter = "blur(35px)";
                document.body.style.backgroundRepeat = "no-repeat";
                document.body.style.backgroundImage = `linear-gradient(to bottom, rgba(${from} 0.38), rgba(${to} 0.8)), url(${imageUrl})`;

                dispatch({
                  type: ActionTypes.TRACK_UPDATE,
                  payload: {
                    currentTrack: {
                      uri: current_track?.uri,
                      name: current_track?.name,
                      imageUrl,
                    },
                  },
                });
              }
            );
          });

          await player.connect();
        }
      };
    }
    // eslint-disable-next-line
  }, [accessToken, currentTrack, refreshToken, setAuthData]);

  if (st === STATUS.ERROR) {
    return (
      <>
        <Head>
          <title>Error | zer0eXploitify</title>
          <meta
            name="description"
            content="zer0eXploit's custom spotify player"
          />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <link rel="icon" href="/favicon.ico" />
        </Head>
        <Container height="100vh">
          <AlertDialog
            isOpen
            leastDestructiveRef={cancelRef}
            onClose={() => {}}
          >
            <AlertDialogOverlay>
              <AlertDialogContent>
                <AlertDialogHeader fontSize="lg" fontWeight="bold">
                  Fatal Error
                </AlertDialogHeader>
                <AlertDialogBody>
                  In most cases, the error is due to your Spotify account not
                  being in an active premium subscription. Please try refreshing
                  the page again. Sorry for the inconvenience caused.
                </AlertDialogBody>
                <AlertDialogFooter>
                  <Button
                    onClick={() => {
                      window.location.href = "/";
                    }}
                    ml={3}
                  >
                    Try Again
                  </Button>
                </AlertDialogFooter>
              </AlertDialogContent>
            </AlertDialogOverlay>
          </AlertDialog>
        </Container>
      </>
    );
  }

  return (
    <>
      <Head>
        <title>
          {currentTrack?.name
            ? `${currentTrack.name} | zer0eXploitify`
            : "Player | zer0eXploitify"}
        </title>
        <meta
          name="description"
          content="zer0eXploit's custom spotify player"
        />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Container height="100vh">
        {currentTrack?.imageUrl && currentTrack?.name && <Search />}
        {currentTrack?.imageUrl && currentTrack?.name && (
          <Flex
            gap="1rem"
            height="100%"
            align="center"
            justify="center"
            direction="column"
          >
            <Image
              boxSize="300px"
              objectFit="cover"
              alt={currentTrack?.name}
              borderRadius="md"
              src={currentTrack?.imageUrl}
            />
            <Text fontSize="md" as="b" color="whitesmoke">
              {currentTrack.name}
            </Text>
            <Flex justify="center" align="center" gap="1rem">
              <Button
                onClick={async () => {
                  const payload = { st: STATUS.PENDING, op: OP.PREV };
                  dispatch({ payload, type: ActionTypes.TOGGLE });
                  await spotifyAPI
                    .post("/me/player/previous", null, {
                      headers: { authorization: `Bearer ${accessToken}` },
                    })
                    .catch(() => {
                      toast({
                        title: "Operation Error",
                        description:
                          "Could not go back to the previous song. Please try again.",
                        status: "error",
                        position: "top",
                        isClosable: true,
                      });
                      payload.st = STATUS.RESOLVED;
                      dispatch({ payload, type: ActionTypes.TOGGLE });
                    })
                    .finally(() => {
                      payload.st = STATUS.RESOLVED;
                      dispatch({ payload, type: ActionTypes.TOGGLE });
                    });
                }}
                isLoading={st === STATUS.PENDING && op === OP.PREV}
                spinner={<BeatLoader size={8} color="black" />}
              >
                Prev
              </Button>
              <Button
                isLoading={st === STATUS.PENDING && op === OP.PLAYPAUSE}
                spinner={<BeatLoader size={8} color="black" />}
                onClick={async () => {
                  const payload: State = {
                    op: OP.PLAYPAUSE,
                    st: STATUS.PENDING,
                  };

                  try {
                    if (playing) {
                      dispatch({ payload, type: ActionTypes.TOGGLE });
                      await spotifyAPI.put("/me/player/pause", null, {
                        headers: { authorization: `Bearer ${accessToken}` },
                      });
                      payload.playing = false;
                      payload.st = STATUS.RESOLVED;
                      dispatch({ payload, type: ActionTypes.TOGGLE });
                    } else {
                      dispatch({ payload, type: ActionTypes.TOGGLE });
                      await spotifyAPI.put("/me/player/play", null, {
                        headers: { authorization: `Bearer ${accessToken}` },
                      });
                      payload.playing = true;
                      payload.st = STATUS.RESOLVED;
                      dispatch({ payload, type: ActionTypes.TOGGLE });
                    }
                  } catch (error) {
                    const payload = { st: STATUS.RESOLVED };
                    dispatch({ payload, type: ActionTypes.TOGGLE });
                    toast({
                      status: "error",
                      position: "top",
                      isClosable: true,
                      title: "Operation Error",
                      description: "Could toggle playback. Please try again.",
                    });
                  }
                }}
              >
                {playing ? "Pause" : "Play"}
              </Button>
              <Button
                isLoading={st === STATUS.PENDING && op === OP.NEXT}
                spinner={<BeatLoader size={8} color="black" />}
                onClick={async () => {
                  const payload = { st: STATUS.PENDING, op: OP.NEXT };
                  dispatch({ payload, type: ActionTypes.TOGGLE });
                  await spotifyAPI
                    .post("/me/player/next", null, {
                      headers: { authorization: `Bearer ${accessToken}` },
                    })
                    .catch(() => {
                      toast({
                        title: "Operation Error",
                        description:
                          "Could not skip to the next song. Please try again.",
                        position: "top",
                        status: "error",
                        isClosable: true,
                      });
                      payload.st = STATUS.RESOLVED;
                      dispatch({ payload, type: ActionTypes.TOGGLE });
                    })
                    .finally(() => {
                      payload.st = STATUS.RESOLVED;
                      dispatch({ payload, type: ActionTypes.TOGGLE });
                    });
                }}
              >
                Next
              </Button>
            </Flex>
          </Flex>
        )}
        {!currentTrack?.imageUrl && (
          <Flex justify="center" align="center" height="100%">
            <Stack spacing={3} align="center">
              <Spinner
                thickness="4px"
                speed="0.7s"
                emptyColor="gray.200"
                color="green.300"
                size="xl"
              />
              <Text fontSize="md">Transferring playback...</Text>
            </Stack>
          </Flex>
        )}
      </Container>
    </>
  );
}
