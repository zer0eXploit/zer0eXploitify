import {
  Text,
  Flex,
  Image,
  Stack,
  Button,
  Spinner,
  Container,
} from "@chakra-ui/react";
import axios from "axios";
import Head from "next/head";
import { BeatLoader } from "react-spinners";
import { useEffect, useRef, useReducer, useState } from "react";

import { useAuth } from "../../context/auth-context";

import { delay, spotifyAPI } from "../../utils";

declare global {
  interface Window {
    Spotify: any;
    Vibrant: any;
    onSpotifyWebPlaybackSDKReady: any;
  }
}

enum ActionTypes {
  TOGGLE = "TOGGLE",
  TRACK_UPDATE = "TRACK_UPDATE",
}

enum STATUS {
  IDLE = "IDLE",
  ERROR = "ERROR",
  PENDING = "PENDING",
  RESOLVED = "RESOLVED",
}

enum OP {
  PREV = "PREV",
  NEXT = "NEXT",
  NONE = "NONE",
  PLAYPAUSE = "PLAYPAUSE",
}

type CurrentTrack = {
  uri: string | null;
  name: string | null;
  imageUrl: string | null;
};

interface State {
  playing?: boolean;
  activated?: boolean;
  currentTrack?: CurrentTrack;
}

interface Action {
  type: ActionTypes;
  payload: State;
}

const initialState: State = {
  playing: false,
  activated: false,
  currentTrack: {
    uri: null,
    name: null,
    imageUrl: null,
  },
};

const reducer = (state: State, action: Action) => {
  switch (action.type) {
    case ActionTypes.TOGGLE:
      return { ...state, ...action.payload };
    case ActionTypes.TRACK_UPDATE:
      return { ...state, ...action.payload };

    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
};

export default function Player() {
  const playerRef = useRef<any>(null);
  const { accessToken, refreshToken, setAuthData } = useAuth();
  const [{ playing, activated, currentTrack }, dispatch] = useReducer(
    reducer,
    initialState
  );
  const [deviceId, setDeviceId] = useState<null | string>(null);
  const [status, setStatus] = useState({ st: STATUS.IDLE, op: OP.NONE });

  useEffect(() => {
    if (!accessToken) {
      window.location.href = "/";
    }
  });

  useEffect(() => {
    // transfer player
    deviceId &&
      spotifyAPI({
        url: "/me/player",
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`,
        },
        data: {
          play: playing ? true : false,
          device_ids: [deviceId],
        },
      });
    // eslint-disable-next-line
  }, [accessToken, deviceId]);

  useEffect(() => {
    if (
      typeof window !== "undefined" &&
      accessToken?.length > 0 &&
      !activated
    ) {
      let done = false;

      window.onSpotifyWebPlaybackSDKReady = async () => {
        playerRef.current = new window.Spotify.Player({
          name: "zer0eXploitify",
          getOAuthToken: async (cb: (token: string) => void) => {
            if (!done) {
              cb(accessToken);
              done = true;
            } else {
              // try to get a new access token with the refresh token
              console.log("[Auth]: Refreshing access token...");
              if (refreshToken) {
                try {
                  const resp = await axios.post("/api/v1/auth/spotify", {
                    refreshToken,
                  });
                  setAuthData({
                    refreshToken,
                    accessToken: resp?.data?.accessToken,
                  });
                  cb(resp?.data?.accessToken);
                } catch (error) {
                  // will force user to login again
                  setAuthData({});
                }
              }
            }
          },
          volume: 0.5,
        });

        const player: any = playerRef.current;
        if (player) {
          // Ready
          player.addListener("ready", ({ device_id }: any) => {
            setDeviceId(device_id);
            console.log("Ready with Device ID", device_id);
          });

          player.addListener("not_ready", ({ device_id }: any) => {
            console.log("Device ID has gone offline", device_id);
          });

          player.addListener("initialization_error", ({ message }: any) => {
            console.error(message);
          });

          player.addListener("authentication_error", ({ message }: any) => {
            // accessToken expired or there is none
            console.error(message);
          });

          player.addListener("account_error", ({ message }: any) => {
            console.error(message);
          });

          player.addListener("player_state_changed", (payload: any) => {
            const { track_window, paused } = payload;
            const { current_track } = track_window;
            const images = track_window?.current_track?.album.images ?? [];
            const imageUrl = images[images.length - 1]?.url ?? "";

            if (currentTrack?.uri === current_track.uri) return;

            if (paused) {
              dispatch({
                type: ActionTypes.TOGGLE,
                payload: { playing: false },
              });
            } else {
              dispatch({
                type: ActionTypes.TOGGLE,
                payload: { playing: true },
              });
            }

            window.Vibrant.from(imageUrl).getPalette(
              (_err: any, palette: any) => {
                const { LightMuted, Vibrant } = palette;

                const from = Vibrant.rgb.reduce(
                  (color: string, cur: number) => color + cur.toFixed(2) + ", ",
                  ""
                );
                const to = LightMuted.rgb.reduce(
                  (color: string, cur: number) => color + cur.toFixed(2) + ", ",
                  ""
                );

                document.body.style.backgroundSize = "cover";
                document.body.style.backdropFilter = "blur(15px)";
                document.body.style.backgroundRepeat = "no-repeat";
                document.body.style.backgroundImage = `linear-gradient(to bottom, rgba(${from} 0.38), rgba(${to} 0.8)), url(${imageUrl})`;

                dispatch({
                  type: ActionTypes.TRACK_UPDATE,
                  payload: {
                    currentTrack: {
                      uri: current_track?.uri,
                      name: current_track?.name,
                      imageUrl,
                    },
                  },
                });
              }
            );
          });

          await player.connect();
        }
      };
    }
  }, [accessToken, currentTrack, activated, refreshToken, setAuthData]);

  return (
    <>
      <Head>
        <title>
          {currentTrack?.name
            ? `${currentTrack.name} | zer0eXploitify"}`
            : "Player | zer0eXploitify"}
        </title>
        <meta
          name="description"
          content="zer0eXploit's custom spotify player"
        />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Container height="100vh">
        {currentTrack?.imageUrl && currentTrack?.name && (
          <Flex
            gap="1rem"
            height="100%"
            align="center"
            justify="center"
            direction="column"
          >
            <Image
              boxSize="300px"
              objectFit="cover"
              alt={currentTrack?.name}
              borderRadius="md"
              src={currentTrack?.imageUrl}
            />
            <Text fontSize="3xl" as="b" color="whitesmoke">
              {currentTrack.name}
            </Text>
            <Flex justify="center" align="center" gap="1rem">
              <Button
                onClick={async () => {
                  if (playerRef.current) {
                    setStatus({ st: STATUS.PENDING, op: OP.PREV });
                    await playerRef.current.previousTrack();
                    await delay(
                      setStatus,
                      [{ st: STATUS.RESOLVED, op: OP.PREV }],
                      500
                    );
                  }
                }}
                isLoading={
                  status.st === STATUS.PENDING && status.op === OP.PREV
                }
                spinner={<BeatLoader size={8} color="black" />}
              >
                Prev
              </Button>
              <Button
                isLoading={
                  status.st === STATUS.PENDING && status.op === OP.PLAYPAUSE
                }
                spinner={<BeatLoader size={8} color="black" />}
                onClick={async () => {
                  if (playerRef.current) {
                    setStatus({ st: STATUS.PENDING, op: OP.PLAYPAUSE });
                    if (!activated) {
                      playerRef.current.resume().then(() => {
                        dispatch({
                          type: ActionTypes.TOGGLE,
                          payload: { playing: true, activated: true },
                        });
                      });
                      // if not active, activate element
                      // refer to spotify web docs as to why it is required.
                      playerRef.current.activateElement();
                    } else {
                      if (playing) {
                        playerRef.current.pause().then(() => {
                          dispatch({
                            type: ActionTypes.TOGGLE,
                            payload: { playing: false },
                          });
                        });
                      } else {
                        playerRef.current.resume().then(() => {
                          dispatch({
                            type: ActionTypes.TOGGLE,
                            payload: { playing: true },
                          });
                        });
                      }
                    }
                    await delay(
                      setStatus,
                      [{ st: STATUS.RESOLVED, op: OP.PLAYPAUSE }],
                      200
                    );
                  }
                }}
              >
                {playing ? "Pause" : "Play"}
              </Button>
              <Button
                isLoading={
                  status.st === STATUS.PENDING && status.op === OP.NEXT
                }
                spinner={<BeatLoader size={8} color="black" />}
                onClick={async () => {
                  if (playerRef.current) {
                    setStatus({ st: STATUS.PENDING, op: OP.NEXT });
                    await playerRef.current.nextTrack();
                    await delay(
                      setStatus,
                      [{ st: STATUS.RESOLVED, op: OP.NEXT }],
                      500
                    );
                  }
                }}
              >
                Next
              </Button>
            </Flex>
          </Flex>
        )}
        {!currentTrack?.imageUrl && (
          <Flex justify="center" align="center" height="100%">
            <Stack spacing={3} align="center">
              <Spinner
                thickness="4px"
                speed="0.35s"
                emptyColor="gray.200"
                color="green.300"
                size="xl"
              />
              <Text fontSize="md">Transferring playback...</Text>
            </Stack>
          </Flex>
        )}
      </Container>
    </>
  );
}
